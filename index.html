<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Market Share - Ribbon Chart</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        /* 1. Estructura Flexbox de Pantalla Completa */
        html, body {
            height: 100vh; /* Alto exacto del viewport del iframe */
            width: 100vw;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prohibido el scroll */
            font-family: 'Segoe UI', Arial, sans-serif;
            background-color: #ffffff;
            display: flex;
            flex-direction: column; /* Apilar elementos verticalmente */
        }

        /* 2. Encabezado Fijo (No se encoge) */
        #header-area {
            flex: 0 0 auto; /* Tamaño fijo basado en contenido */
            text-align: center;
            padding: 10px 0 5px 0;
        }
        h1 { margin: 0; font-size: 16px; color: #333; }

        /* 3. Área del Gráfico (Flexible) */
        /* LA CLAVE: min-height: 0 permite que este div se encoja si es necesario */
        #chart-wrapper {
            flex: 1 1 auto; 
            min-height: 0; 
            width: 100%;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* 4. Leyenda Fija (No se encoge) */
        #legend-area {
            flex: 0 0 auto;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 15px;
            padding: 5px 10px 10px 10px;
        }

        /* Estilos generales D3 */
        .legend-item { display: flex; align-items: center; gap: 5px; font-size: 11px; }
        .legend-color { width: 12px; height: 12px; border-radius: 2px; }
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
            top: 0; left: 0;
        }
        .axis text { font-size: 10px; fill: #666; }
        .axis line, .axis path { stroke: #ddd; }
        .grid line { stroke: #f0f0f0; stroke-dasharray: 2,2; }
        .ribbon { opacity: 0.8; transition: opacity 0.2s; }
        .ribbon:hover { opacity: 1; }
    </style>
</head>
<body>

    <div id="header-area">
        <h1>Market Share por Mes (%)</h1>
    </div>

    <div id="chart-wrapper">
        <svg id="ribbon-chart"></svg>
    </div>

    <div id="legend-area"></div>
    
    <div class="tooltip" id="tooltip"></div>

    <script>
        // --- DATOS ---
        const data = [
            { mes: 'ENE', SUZUKI: 26, HONDA: 26, YAMAHA: 15, AUTECO: 12, AKT: 8, HERO: 7, SYM: 6 },
            { mes: 'FEB', SUZUKI: 26, HONDA: 23, YAMAHA: 17, AUTECO: 13, AKT: 9, HERO: 6, SYM: 6 },
            { mes: 'MAR', SUZUKI: 23, HONDA: 27, YAMAHA: 16, AUTECO: 12, AKT: 9, HERO: 7, SYM: 6 },
            { mes: 'ABR', SUZUKI: 23, HONDA: 27, YAMAHA: 16, AUTECO: 13, AKT: 9, HERO: 6, SYM: 6 },
            { mes: 'MAY', SUZUKI: 27, HONDA: 23, YAMAHA: 15, AUTECO: 13, AKT: 10, HERO: 6, SYM: 6 },
            { mes: 'JUN', SUZUKI: 21, HONDA: 27, YAMAHA: 17, AUTECO: 13, AKT: 10, HERO: 6, SYM: 6 },
            { mes: 'JUL', SUZUKI: 25, HONDA: 23, YAMAHA: 16, AUTECO: 13, AKT: 11, HERO: 6, SYM: 6 },
            { mes: 'AGO', SUZUKI: 23, HONDA: 24, YAMAHA: 17, AUTECO: 13, AKT: 11, HERO: 6, SYM: 6 },
            { mes: 'SEP', SUZUKI: 23, HONDA: 24, YAMAHA: 17, AUTECO: 13, AKT: 11, HERO: 6, SYM: 6 },
            { mes: 'OCT', SUZUKI: 24, HONDA: 23, YAMAHA: 17, AUTECO: 14, AKT: 10, HERO: 6, SYM: 6 },
            { mes: 'NOV', SUZUKI: 24, HONDA: 24, YAMAHA: 16, AUTECO: 14, AKT: 10, HERO: 6, SYM: 6 }
        ];

        const brands = ['SUZUKI', 'HONDA', 'YAMAHA', 'AUTECO', 'AKT', 'HERO', 'SYM'];
        const colors = {
            'SUZUKI': '#4CAF50', 'HONDA': '#F44336', 'YAMAHA': '#2196F3',
            'AUTECO': '#9E9E9E', 'AKT': '#FF9800', 'HERO': '#795548', 'SYM': '#B0BEC5'
        };

        // Renderizar Leyenda una sola vez
        const legendContainer = d3.select('#legend-area');
        brands.forEach(brand => {
            const item = legendContainer.append('div').attr('class', 'legend-item');
            item.append('div').attr('class', 'legend-color').style('background-color', colors[brand]);
            item.append('span').text(brand);
        });

        // --- FUNCIÓN DE DIBUJADO PRINCIPAL ---
        function drawChart() {
            // 1. Obtener el contenedor FLEXIBLE (No la ventana)
            const container = document.getElementById('chart-wrapper');
            
            // 2. Medir el espacio disponible real dentro de ese div
            const availableWidth = container.clientWidth;
            const availableHeight = container.clientHeight;

            // Si el contenedor colapsó a 0 (carga inicial), no hacer nada y esperar
            if (availableWidth === 0 || availableHeight === 0) return;

            // 3. Limpiar SVG previo
            d3.select("#ribbon-chart").selectAll("*").remove();

            // 4. Configurar márgenes dentro del SVG
            const margin = { top: 10, right: 25, bottom: 20, left: 35 };
            const width = availableWidth - margin.left - margin.right;
            const height = availableHeight - margin.top - margin.bottom;

            // Seguridad por si los márgenes son mayores al espacio
            if (width <= 0 || height <= 0) return;

            // 5. Crear SVG con dimensiones exactas del div contenedor
            const svg = d3.select('#ribbon-chart')
                .attr('width', availableWidth)
                .attr('height', availableHeight)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // --- Lógica D3 ---
            const x = d3.scaleBand().domain(data.map(d => d.mes)).range([0, width]).padding(0.2);
            const y = d3.scaleLinear().domain([0, 100]).range([height, 0]);

            // Grid y Ejes
            svg.append('g').attr('class', 'grid').call(d3.axisLeft(y).tickSize(-width).tickFormat('').ticks(5));
            svg.append('g').attr('class', 'axis').attr('transform', `translate(0,${height})`).call(d3.axisBottom(x));
            svg.append('g').attr('class', 'axis').call(d3.axisLeft(y).tickFormat(d => d + '%').ticks(5));

            // Procesamiento Datos
            const processedData = data.map(d => {
                const values = brands.map(brand => ({ brand, value: d[brand] }));
                values.sort((a, b) => b.value - a.value);
                let cumulative = 0;
                const bands = values.map(v => {
                    const start = cumulative; cumulative += v.value;
                    return { brand: v.brand, value: v.value, y0: start, y1: cumulative };
                });
                return { mes: d.mes, bands };
            });

            const barWidth = x.bandwidth();
            const tooltip = d3.select('#tooltip');

            brands.forEach(brand => {
                // Cintas
                for (let i = 0; i < processedData.length - 1; i++) {
                    const current = processedData[i];
                    const next = processedData[i + 1];
                    const currentBand = current.bands.find(b => b.brand === brand);
                    const nextBand = next.bands.find(b => b.brand === brand);
                    if (!currentBand || !nextBand) continue;

                    const x0 = x(current.mes);
                    const x1 = x(next.mes);
                    const ribbonPath = `
                        M ${x0},${y(currentBand.y0)} L ${x0 + barWidth},${y(currentBand.y0)} L ${x0 + barWidth},${y(currentBand.y1)} L ${x0},${y(currentBand.y1)} Z
                        M ${x0 + barWidth},${y(currentBand.y0)}
                        C ${x0 + barWidth + (x1 - x0 - barWidth) / 2},${y(currentBand.y0)} ${x1 - (x1 - x0 - barWidth) / 2},${y(nextBand.y0)} ${x1},${y(nextBand.y0)}
                        L ${x1},${y(nextBand.y1)}
                        C ${x1 - (x1 - x0 - barWidth) / 2},${y(nextBand.y1)} ${x0 + barWidth + (x1 - x0 - barWidth) / 2},${y(currentBand.y1)} ${x0 + barWidth},${y(currentBand.y1)} Z
                    `;
                    svg.append('path').attr('class', 'ribbon').attr('d', ribbonPath).attr('fill', colors[brand]).attr('stroke', 'none')
                        .on('mousemove', (event) => {
                            tooltip.style('opacity', 1).html(`<strong>${brand}</strong><br/>${current.mes}: ${currentBand.value}% → ${next.mes}: ${nextBand.value}%`)
                                .style('left', (event.pageX + 10) + 'px').style('top', (event.pageY - 10) + 'px');
                        })
                        .on('mouseout', () => tooltip.style('opacity', 0));
                }
                // Barras verticales
                processedData.forEach((month) => {
                    const band = month.bands.find(b => b.brand === brand);
                    if (!band) return;
                    const xPos = x(month.mes);
                    svg.append('rect').attr('x', xPos).attr('y', y(band.y1)).attr('width', barWidth)
                        .attr('height', Math.max(0, y(band.y0) - y(band.y1))).attr('fill', colors[brand]).attr('opacity', 0.9)
                        .on('mousemove', (event) => {
                            tooltip.style('opacity', 1).html(`<strong>${brand}</strong><br/>${month.mes}: ${band.value}%`)
                                .style('left', (event.pageX + 10) + 'px').style('top', (event.pageY - 10) + 'px');
                        })
                        .on('mouseout', () => tooltip.style('opacity', 0));
                    
                    if (brand === 'HONDA' && band.value > 5) {
                        svg.append('text').attr('x', xPos + barWidth / 2).attr('y', y(band.y1) - 4).attr('text-anchor', 'middle')
                            .attr('fill', colors[brand]).attr('font-weight', 'bold').attr('font-size', '10px').text(band.value + '%');
                    }
                });
            });
        }

        // --- OBSERVADOR DE REDIMENSIONAMIENTO (La parte crítica) ---
        // Esto detecta si el DIV cambia de tamaño, no solo la ventana.
        const resizeObserver = new ResizeObserver(entries => {
            // Usamos requestAnimationFrame para evitar errores de bucle de redimensionamiento
            window.requestAnimationFrame(() => {
                drawChart();
            });
        });

        // Comenzar a observar el contenedor principal
        resizeObserver.observe(document.getElementById('chart-wrapper'));

    </script>
</body>
</html>
