<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Market Share Responsive</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        /* 1. RESET TOTAL */
        html, body {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            overflow: hidden; /* Cero scrollbars */
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #ffffff;
        }

        /* 2. CONTENEDOR MAESTRO - POSICIONAMIENTO ABSOLUTO 
           Esto fuerza al div a ocupar todo el iframe, pase lo que pase con el flexbox padre. */
        #app-container {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            flex-direction: column;
        }

        /* 3. ELEMENTOS FIJOS */
        #header-area { flex: 0 0 auto; padding: 5px; text-align: center; background: #fff; z-index: 10; }
        h1 { margin: 0; font-size: 14px; color: #333; }
        
        #legend-area { 
            flex: 0 0 auto; 
            padding: 5px; 
            display: flex; 
            justify-content: center; 
            flex-wrap: wrap; 
            gap: 10px; 
            background: #fff; 
            z-index: 10; 
            min-height: 30px; /* Evita colapso total */
        }

        /* 4. ÁREA DEL GRÁFICO - LA CLAVE */
        #chart-wrapper {
            flex: 1; /* Ocupa todo el espacio restante */
            position: relative; /* Para posicionar el SVG dentro */
            width: 100%;
            min-height: 0; /* Permite encogerse en Flexbox */
            overflow: hidden;
        }

        /* 5. SVG FLOTANTE */
        #ribbon-chart {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Estilos D3 */
        .legend-item { display: flex; align-items: center; gap: 4px; font-size: 10px; }
        .legend-color { width: 10px; height: 10px; border-radius: 2px; }
        .tooltip {
            position: absolute; background: rgba(0,0,0,0.8); color: white;
            padding: 5px 8px; border-radius: 4px; font-size: 11px;
            pointer-events: none; opacity: 0; transition: opacity 0.2s; z-index: 9999;
        }
        .axis text { font-size: 9px; fill: #666; }
        .axis line, .axis path { stroke: #e0e0e0; }
        .grid line { stroke: #f5f5f5; }
        .ribbon { opacity: 0.85; }
        .ribbon:hover { opacity: 1; }
    </style>
</head>
<body>

    <div id="app-container">
        <div id="header-area"><h1>Market Share por Mes (%)</h1></div>
        
        <div id="chart-wrapper">
            <svg id="ribbon-chart"></svg>
        </div>
        
        <div id="legend-area"></div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>

    <script>
        // --- DATOS ---
        const data = [
            { mes: 'ENE', SUZUKI: 26, HONDA: 26, YAMAHA: 15, AUTECO: 12, AKT: 8, HERO: 7, SYM: 6 },
            { mes: 'FEB', SUZUKI: 26, HONDA: 23, YAMAHA: 17, AUTECO: 13, AKT: 9, HERO: 6, SYM: 6 },
            { mes: 'MAR', SUZUKI: 23, HONDA: 27, YAMAHA: 16, AUTECO: 12, AKT: 9, HERO: 7, SYM: 6 },
            { mes: 'ABR', SUZUKI: 23, HONDA: 27, YAMAHA: 16, AUTECO: 13, AKT: 9, HERO: 6, SYM: 6 },
            { mes: 'MAY', SUZUKI: 27, HONDA: 23, YAMAHA: 15, AUTECO: 13, AKT: 10, HERO: 6, SYM: 6 },
            { mes: 'JUN', SUZUKI: 21, HONDA: 27, YAMAHA: 17, AUTECO: 13, AKT: 10, HERO: 6, SYM: 6 },
            { mes: 'JUL', SUZUKI: 25, HONDA: 23, YAMAHA: 16, AUTECO: 13, AKT: 11, HERO: 6, SYM: 6 },
            { mes: 'AGO', SUZUKI: 23, HONDA: 24, YAMAHA: 17, AUTECO: 13, AKT: 11, HERO: 6, SYM: 6 },
            { mes: 'SEP', SUZUKI: 23, HONDA: 24, YAMAHA: 17, AUTECO: 13, AKT: 11, HERO: 6, SYM: 6 },
            { mes: 'OCT', SUZUKI: 24, HONDA: 23, YAMAHA: 17, AUTECO: 14, AKT: 10, HERO: 6, SYM: 6 },
            { mes: 'NOV', SUZUKI: 24, HONDA: 24, YAMAHA: 16, AUTECO: 14, AKT: 10, HERO: 6, SYM: 6 }
        ];
        const brands = ['SUZUKI', 'HONDA', 'YAMAHA', 'AUTECO', 'AKT', 'HERO', 'SYM'];
        const colors = { 'SUZUKI': '#4CAF50', 'HONDA': '#F44336', 'YAMAHA': '#2196F3', 'AUTECO': '#9E9E9E', 'AKT': '#FF9800', 'HERO': '#795548', 'SYM': '#B0BEC5' };

        // Leyenda Estática
        const legendContainer = d3.select('#legend-area');
        brands.forEach(brand => {
            const item = legendContainer.append('div').attr('class', 'legend-item');
            item.append('div').attr('class', 'legend-color').style('background-color', colors[brand]);
            item.append('span').text(brand);
        });

        // --- MOTOR DE DIBUJADO ---
        let lastWidth = 0;
        let lastHeight = 0;

        function drawChart() {
            // 1. Obtener dimensiones del WRAPPER (no de la ventana)
            const container = document.getElementById('chart-wrapper');
            if (!container) return;

            // getBoundingClientRect es más preciso que clientWidth/Height
            const rect = container.getBoundingClientRect();
            const width = Math.floor(rect.width);
            const height = Math.floor(rect.height);

            // 2. FILTRO DE SEGURIDAD:
            // Si el tamaño es 0 (común al inicio) o IGUAL al anterior, no hacer nada.
            if (width < 10 || height < 10) return;
            if (width === lastWidth && height === lastHeight) return;

            // Actualizamos registro
            lastWidth = width;
            lastHeight = height;

            // 3. Limpiar y redibujar
            const svg = d3.select('#ribbon-chart');
            svg.selectAll("*").remove();

            // Márgenes
            const margin = { top: 10, right: 15, bottom: 20, left: 30 };
            const innerW = width - margin.left - margin.right;
            const innerH = height - margin.top - margin.bottom;

            const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

            // Escalas
            const x = d3.scaleBand().domain(data.map(d => d.mes)).range([0, innerW]).padding(0.2);
            const y = d3.scaleLinear().domain([0, 100]).range([innerH, 0]);

            // Grid y Ejes
            g.append('g').attr('class', 'grid').call(d3.axisLeft(y).tickSize(-innerW).tickFormat('').ticks(5));
            g.append('g').attr('class', 'axis').attr('transform', `translate(0,${innerH})`).call(d3.axisBottom(x));
            g.append('g').attr('class', 'axis').call(d3.axisLeft(y).tickFormat(d => d + '%').ticks(5));

            // Procesamiento de datos
            const processedData = data.map(d => {
                const values = brands.map(brand => ({ brand, value: d[brand] }));
                values.sort((a, b) => b.value - a.value);
                let cumulative = 0;
                const bands = values.map(v => {
                    const start = cumulative; cumulative += v.value;
                    return { brand: v.brand, value: v.value, y0: start, y1: cumulative };
                });
                return { mes: d.mes, bands };
            });

            const barWidth = x.bandwidth();
            const tooltip = d3.select('#tooltip');

            // Dibujar
            brands.forEach(brand => {
                // Cintas
                for (let i = 0; i < processedData.length - 1; i++) {
                    const curr = processedData[i];
                    const next = processedData[i + 1];
                    const cb = curr.bands.find(b => b.brand === brand);
                    const nb = next.bands.find(b => b.brand === brand);
                    if (!cb || !nb) continue;

                    const x0 = x(curr.mes);
                    const x1 = x(next.mes);
                    const path = `
                        M ${x0},${y(cb.y0)} L ${x0+barWidth},${y(cb.y0)} L ${x0+barWidth},${y(cb.y1)} L ${x0},${y(cb.y1)} Z
                        M ${x0+barWidth},${y(cb.y0)} 
                        C ${x0+barWidth + (x1-x0-barWidth)/2},${y(cb.y0)} ${x1-(x1-x0-barWidth)/2},${y(nb.y0)} ${x1},${y(nb.y0)}
                        L ${x1},${y(nb.y1)}
                        C ${x1-(x1-x0-barWidth)/2},${y(nb.y1)} ${x0+barWidth + (x1-x0-barWidth)/2},${y(cb.y1)} ${x0+barWidth},${y(cb.y1)} Z
                    `;
                    g.append('path').attr('class', 'ribbon').attr('d', path).attr('fill', colors[brand]).attr('stroke', 'none')
                     .on('mousemove', e => tooltip.style('opacity',1).html(`<strong>${brand}</strong><br/>${curr.mes}: ${cb.value}%`).style('left',(e.pageX+10)+'px').style('top',(e.pageY-10)+'px'))
                     .on('mouseout', () => tooltip.style('opacity',0));
                }
                // Barras
                processedData.forEach(m => {
                    const b = m.bands.find(v => v.brand === brand);
                    if(!b) return;
                    g.append('rect').attr('x', x(m.mes)).attr('y', y(b.y1)).attr('width', barWidth).attr('height', Math.max(0, y(b.y0)-y(b.y1)))
                     .attr('fill', colors[brand]).attr('opacity', 0.9)
                     .on('mousemove', e => tooltip.style('opacity',1).html(`<strong>${brand}</strong><br/>${m.mes}: ${b.value}%`).style('left',(e.pageX+10)+'px').style('top',(e.pageY-10)+'px'))
                     .on('mouseout', () => tooltip.style('opacity',0));
                    
                    if(brand==='HONDA' && b.value>5) {
                        g.append('text').attr('x', x(m.mes)+barWidth/2).attr('y', y(b.y1)-2).attr('text-anchor', 'middle')
                         .attr('fill', colors[brand]).attr('font-weight','bold').attr('font-size','8px').text(b.value+'%');
                    }
                });
            });
        }

        // --- SISTEMA DE DETECCIÓN ROBUSTO ---
        
        // 1. ResizeObserver: La forma moderna estándar
        const observer = new ResizeObserver(() => requestAnimationFrame(drawChart));
        observer.observe(document.getElementById('chart-wrapper'));

        // 2. Polling de Respaldo: Revisa el tamaño 10 veces durante los primeros 2 segundos
        // Esto corrige el caso donde el ResizeObserver no se dispara al inicio si el iframe estaba oculto
        let attempts = 0;
        const interval = setInterval(() => {
            drawChart();
            attempts++;
            if (attempts > 20) clearInterval(interval); // Parar después de 2 segundos (20 * 100ms)
        }, 100);

        // 3. Evento Window standard
        window.addEventListener('resize', drawChart);

    </script>
</body>
</html>
