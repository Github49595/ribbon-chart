<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Market Share Responsive</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        /* 1. Forzar a la página a ocupar todo el IFrame sin scroll */
        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Arial, sans-serif;
            display: flex;
            flex-direction: column;
        }

        /* 2. Encabezado Fijo */
        #header-area {
            flex: 0 0 auto;
            text-align: center;
            padding: 5px 0;
        }
        h1 { margin: 0; font-size: 14px; color: #333; }

        /* 3. El contenedor del gráfico es "Elástico" */
        #chart-wrapper {
            flex: 1; /* Ocupa todo el espacio sobrante */
            width: 100%;
            position: relative;
            min-height: 0; /* Crucial para Flexbox */
            overflow: hidden;
        }

        /* 4. El SVG se estira para llenar el wrapper automáticamente */
        #ribbon-chart {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* 5. Leyenda Fija en la base */
        #legend-area {
            flex: 0 0 auto;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            padding: 5px;
            background: #fff;
        }

        /* Estilos Gráficos */
        .legend-item { display: flex; align-items: center; gap: 4px; font-size: 10px; }
        .legend-color { width: 10px; height: 10px; border-radius: 2px; }
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 11px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 9999;
        }
        .axis text { font-size: 9px; fill: #666; }
        .axis line, .axis path { stroke: #e0e0e0; }
        .grid line { stroke: #f5f5f5; }
        .ribbon { opacity: 0.85; }
        .ribbon:hover { opacity: 1; }
    </style>
</head>
<body>

    <div id="header-area">
        <h1>Market Share por Mes (%)</h1>
    </div>

    <div id="chart-wrapper">
        <svg id="ribbon-chart"></svg>
    </div>

    <div id="legend-area"></div>
    <div class="tooltip" id="tooltip"></div>

    <script>
        // --- DATOS ---
        const data = [
            { mes: 'ENE', SUZUKI: 26, HONDA: 26, YAMAHA: 15, AUTECO: 12, AKT: 8, HERO: 7, SYM: 6 },
            { mes: 'FEB', SUZUKI: 26, HONDA: 23, YAMAHA: 17, AUTECO: 13, AKT: 9, HERO: 6, SYM: 6 },
            { mes: 'MAR', SUZUKI: 23, HONDA: 27, YAMAHA: 16, AUTECO: 12, AKT: 9, HERO: 7, SYM: 6 },
            { mes: 'ABR', SUZUKI: 23, HONDA: 27, YAMAHA: 16, AUTECO: 13, AKT: 9, HERO: 6, SYM: 6 },
            { mes: 'MAY', SUZUKI: 27, HONDA: 23, YAMAHA: 15, AUTECO: 13, AKT: 10, HERO: 6, SYM: 6 },
            { mes: 'JUN', SUZUKI: 21, HONDA: 27, YAMAHA: 17, AUTECO: 13, AKT: 10, HERO: 6, SYM: 6 },
            { mes: 'JUL', SUZUKI: 25, HONDA: 23, YAMAHA: 16, AUTECO: 13, AKT: 11, HERO: 6, SYM: 6 },
            { mes: 'AGO', SUZUKI: 23, HONDA: 24, YAMAHA: 17, AUTECO: 13, AKT: 11, HERO: 6, SYM: 6 },
            { mes: 'SEP', SUZUKI: 23, HONDA: 24, YAMAHA: 17, AUTECO: 13, AKT: 11, HERO: 6, SYM: 6 },
            { mes: 'OCT', SUZUKI: 24, HONDA: 23, YAMAHA: 17, AUTECO: 14, AKT: 10, HERO: 6, SYM: 6 },
            { mes: 'NOV', SUZUKI: 24, HONDA: 24, YAMAHA: 16, AUTECO: 14, AKT: 10, HERO: 6, SYM: 6 }
        ];

        const brands = ['SUZUKI', 'HONDA', 'YAMAHA', 'AUTECO', 'AKT', 'HERO', 'SYM'];
        const colors = {
            'SUZUKI': '#4CAF50', 'HONDA': '#F44336', 'YAMAHA': '#2196F3',
            'AUTECO': '#9E9E9E', 'AKT': '#FF9800', 'HERO': '#795548', 'SYM': '#B0BEC5'
        };

        // Pintar Leyenda una sola vez
        const legendContainer = d3.select('#legend-area');
        brands.forEach(brand => {
            const item = legendContainer.append('div').attr('class', 'legend-item');
            item.append('div').attr('class', 'legend-color').style('background-color', colors[brand]);
            item.append('span').text(brand);
        });

        // --- FUNCIÓN DE DIBUJADO ---
        function drawChart() {
            // 1. Obtener referencia al SVG
            const svg = d3.select('#ribbon-chart');
            
            // 2. Limpiar contenido anterior
            svg.selectAll("*").remove();

            // 3. MEDIR EL TAMAÑO REAL QUE EL CSS LE DIO AL SVG
            // Esta es la clave: preguntamos al navegador cuánto mide ahora mismo
            const boundingBox = svg.node().getBoundingClientRect();
            const width = boundingBox.width;
            const height = boundingBox.height;

            // Si es muy pequeño (carga inicial fallida), abortar
            if (width < 50 || height < 50) return;

            // 4. Definir márgenes internos para ejes
            const margin = { top: 10, right: 10, bottom: 20, left: 30 };
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;

            // Grupo principal
            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // --- ESCALAS D3 ---
            const x = d3.scaleBand().domain(data.map(d => d.mes)).range([0, innerWidth]).padding(0.2);
            const y = d3.scaleLinear().domain([0, 100]).range([innerHeight, 0]);

            // Grid y Ejes
            g.append('g').attr('class', 'grid').call(d3.axisLeft(y).tickSize(-innerWidth).tickFormat('').ticks(5));
            g.append('g').attr('class', 'axis').attr('transform', `translate(0,${innerHeight})`).call(d3.axisBottom(x));
            g.append('g').attr('class', 'axis').call(d3.axisLeft(y).tickFormat(d => d + '%').ticks(5));

            // Procesar Datos
            const processedData = data.map(d => {
                const values = brands.map(brand => ({ brand, value: d[brand] }));
                values.sort((a, b) => b.value - a.value);
                let cumulative = 0;
                const bands = values.map(v => {
                    const start = cumulative; cumulative += v.value;
                    return { brand: v.brand, value: v.value, y0: start, y1: cumulative };
                });
                return { mes: d.mes, bands };
            });

            const barWidth = x.bandwidth();
            const tooltip = d3.select('#tooltip');

            // Dibujar Cintas y Barras
            brands.forEach(brand => {
                // Cintas curvas
                for (let i = 0; i < processedData.length - 1; i++) {
                    const current = processedData[i];
                    const next = processedData[i + 1];
                    const cBand = current.bands.find(b => b.brand === brand);
                    const nBand = next.bands.find(b => b.brand === brand);
                    if (!cBand || !nBand) continue;

                    const x0 = x(current.mes);
                    const x1 = x(next.mes);
                    
                    const path = `
                        M ${x0},${y(cBand.y0)} L ${x0+barWidth},${y(cBand.y0)} L ${x0+barWidth},${y(cBand.y1)} L ${x0},${y(cBand.y1)} Z
                        M ${x0+barWidth},${y(cBand.y0)} 
                        C ${x0+barWidth + (x1-x0-barWidth)/2},${y(cBand.y0)} ${x1-(x1-x0-barWidth)/2},${y(nBand.y0)} ${x1},${y(nBand.y0)}
                        L ${x1},${y(nBand.y1)}
                        C ${x1-(x1-x0-barWidth)/2},${y(nBand.y1)} ${x0+barWidth + (x1-x0-barWidth)/2},${y(cBand.y1)} ${x0+barWidth},${y(cBand.y1)} Z
                    `;
                    g.append('path').attr('class', 'ribbon').attr('d', path).attr('fill', colors[brand]).attr('stroke', 'none')
                     .on('mousemove', e => tooltip.style('opacity',1).html(`<strong>${brand}</strong><br/>${current.mes}: ${cBand.value}%`).style('left',(e.pageX+10)+'px').style('top',(e.pageY-10)+'px'))
                     .on('mouseout', () => tooltip.style('opacity',0));
                }
                
                // Barras verticales
                processedData.forEach(m => {
                    const b = m.bands.find(x => x.brand === brand);
                    if(!b) return;
                    g.append('rect').attr('x', x(m.mes)).attr('y', y(b.y1)).attr('width', barWidth).attr('height', Math.max(0, y(b.y0)-y(b.y1)))
                     .attr('fill', colors[brand]).attr('opacity', 0.9)
                     .on('mousemove', e => tooltip.style('opacity',1).html(`<strong>${brand}</strong><br/>${m.mes}: ${b.value}%`).style('left',(e.pageX+10)+'px').style('top',(e.pageY-10)+'px'))
                     .on('mouseout', () => tooltip.style('opacity',0));
                    
                    // Etiqueta Honda
                    if(brand==='HONDA' && b.value>5) {
                        g.append('text').attr('x', x(m.mes)+barWidth/2).attr('y', y(b.y1)-2).attr('text-anchor', 'middle')
                         .attr('fill', colors[brand]).attr('font-weight','bold').attr('font-size','8px').text(b.value+'%');
                    }
                });
            });
        }

        // --- EVENTOS ---
        // 1. Dibujar al cargar
        window.addEventListener('load', drawChart);
        
        // 2. Redibujar al cambiar tamaño de la ventana (Power Apps resizing)
        window.addEventListener('resize', drawChart);

        // 3. Seguridad: Intentar dibujar de nuevo a los 500ms y 1s por si Power Apps animó la apertura
        setTimeout(drawChart, 500);
        setTimeout(drawChart, 1000);

    </script>
</body>
</html>
